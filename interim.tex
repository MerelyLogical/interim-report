\documentclass[journal]{IEEEtran}

\usepackage{cite}
\usepackage{float}
\usepackage{graphicx}
\usepackage[caption=false]{subfig}
  \DeclareGraphicsExtensions{.png}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{url}

\hyphenation{photo-graphed diff-erence}

\begin{document}

\title{%
  High radix On-line Arithmetic Verification System\\
  \large Final Year Project 1800478: Interim Report}
\author{Zifan Wang, 01077639\\Imperial College London}

% \markboth{2018-2019}{?}
\onecolumn
\maketitle
\tableofcontents

\twocolumn
\newpage
% \begin{abstract}
% \end{abstract}

% --------------------------------------------------------------------------------
% --------------------------------------------------------------------------------
\section{Introduction}
% The Interim report should normally be between 10 and 30 pages long. Remember
% that it must be a project planning document for the remainder of your project
% work, as well as being an early write-up of your background material. Using
% Interim Report material, without explicit reference, in your Final Report is
% allowed, and even encouraged. The Interim Report is often a first draft of the
% background section of the Final Report. Self-plagiarism, in this case, is not an
% issue. It is expected that you will reuse Interim Report material without
% explicit reference.
% REVISIT: this is directly from James's project discription
With the right number representation system, it is possible to perform
arithmetic operations MSD-first.
Consequently, these on-line arithmetic operators are attractive
for hardware implementation in both serial and parallel forms.
When computing digits serially, they can be chained such that subsequent
operations begin before the preceding ones complete.
Parallel implementations tend to be most sensitive to failure in their LSD,
making them more friendly to overclocking than their LSD-first counterparts,
for which the opposite is true.

In the past, online operators have typically been implemented in binary.
Along with its sister project,
This project will explore high radix on-line operators,
investigating their suitability for FPGA implementation and examining the
resultant trade-offs between performance, area and power.

% --------------------------------------------------------------------------------
% --------------------------------------------------------------------------------
\section{Background}
% The background section must outline the necessary background to the project,
% stating how it is important for the project work. For example: survey of related
% literature, analysis of competing products, technical specifications of hardware
% or software standards, electronic components, necessary software tools,
% background theory. The contents of this section will vary for different
% projects, and in many cases the background reading will have been completed –
% but if not you should be in a position to list what remains to be done (e.g. a
% set of research papers to read and understand). A good benchmark of progress
% here is that you have accumulated (though may not yet have read) at least 20
% references to background material. In projects which have substantial background
% writing up your literature survey in the Interim Report will save time at the
% end of the project and allow this element of your final report to receive timely
% feedback from your supervisor so the final write-up can be improved.
% REVISIT: Better logic between serial and parallel operators

\subsection{On-line Arithmetic}
Traditional proposals to achieving a faster and more efficient arithmetic
operator have two common characteristics.
One, their order operation may be different depending on the operation itself.
A traditional adder, parallel or serial, generates its answers from the LSD to
the MSD.
A traditional divider design on the other hand, generates its answers from
the MSD to the LSD~\cite{Brent1}\cite{Srinivas1}.

Due to this inconsistency, arithmetic operators may be forced to compute
word-by-word, waiting for all digits to finish in the previous operator before
moving on to the next.~\cite{Zhao1}
This means if a divider follows an adder of the same width, the divider has to
wait until the adder complete its computation before it can start its own.

The other commonality of traditional designs is that their precisions are
specified design-time. Once built, a 32-bit adder always adds 32 bits together,
as the hardware is fixed at run-time.
A possible way of making it more efficient would be using SIMD
instructions~\cite{Duncan1}, trying to combine smaller operations into a larger
one that fits the hardware.
This requires more control circuits in the hardware, or a more complex compiler.

On-line arithmetic does not suffer from the first issue as it performs all
arithmetic operations with MSD first~\cite{Ercegovac1}.
Pipelining can be used with on-line arithmetic operators.
This means the output digit of an earlier operation can be fed into the next
operator before the earlier operation been fully complete.

% REVISIT: Better diagram here
\begin{figure}[H]
  \centering
  \includegraphics[width=8cm]{img/Online}
  \caption{Computing $y=\sqrt{(a+b)cd/(e-f)}$~\cite{Ercegovac1}}
  \label{Online}
\end{figure}

As illustrated in figure~\ref{Online}, while each individual operation may
take longer than its conventional counterpart, on-line arithmetic could provide
a speed up if the operators are in serial.
Individually, on-line arithmetic also sacrifices in terms of memory.
As all computation are made MSD to LSD, the use of a redundant number system
is compulsory.
However, this redundancy also has its advantage in making the operators
scalable.
The time required per digit can be made independent of the length of the
operands.~\cite{Trivedi1}

A recent architecture proposal allows the precision of
on-line arithmetic to be controlled at run-time~\cite{Zhao1}.
Traditionally, this run-time control was restricted due to the parallel adders
present in the multipliers and dividers.
This architecture reuses a fixed-precision adder and stores residues in
on-chip RAM.
As such, a single piece of hardware can be used to calculate to any precision
limited only by the size of the on-chip RAM.

Another way that on-line arithmetic alleviates the problem of fixed precision
falls out directly from its MSD-first nature.
Suppose the output of a conventional ripple adder is sampled before
it has completed its operation.
In this case, the lower digits would have been completed, but the carry would
not have reached the higher ones.
This means the error on the result would be significant, as the top bits
were still undetermined~\cite{Shi1}.

However, if the output of a serial on-line adder is sampled before its
completion, the lower bits would be the undetermined ones.
This means the error of the operation would be small.
With overclocking, on-line arithmetic would fail gracefully, losing its
precision gradually from the lowest bits first.
Thus, it allows for a run-time trade-off between precision and
frequency~\cite{Shi2}.

\subsection{High radix Arithmetic}
Conventional designs of arithmetic operators use binary representations.
This was chosen four decades ago to maximise numerical accuracy per bit of data.
However, using a high radix representation system could yield better numerical
accuracy while reducing area cost of FPGAs.
For example, a hexadecimal floating-point adder has a 30\% smaller area-time
product than its binary counterpart, while still delivering equal worst-case
and better average-case numerical accuracy~\cite{Catanzaro1}.

However, the savings are not without trade-offs.
This trade-off can become unfavourable if the specification requires much I/O
and little computation~\cite{Whyte1}.
This is because the overhead of radix conversion would be significant.
It is also unwise to use high radix representations when the numbers are
unusually small, thus making the savings offered by the high radix
negligible~\cite{Catanzaro1}.

\subsection{High radix On-line Arithmetic}
Using high radix number representations for on-line arithmetic is a
relatively novel concept.
% REVISIT: can find problem with Lynch?
While there have been some research in this field~\cite{Lynch1}\cite{Lynch2},
this project takes a more direct approach by implementing custom operators
made for high radix on-line arithmetic on a FPGA.
This would allow for empirical results to be obtained, hopefully revealing
practical insights to the method.

As an potential extension to the project, optimising this exotic arithmetic
on a system level for popular FPGA accelerations such as neural networks would
be innovative as well.

% REVISIT: what to put here?
% research on possible architectures
% hardware of FPGA
% speed of memory
% launch registers
% PLLs
% HLS vs Verilog?
% LFSR
\subsection{Verification System}
With respect to the testbench, figuring out a system to obtain the optimal point
of operation of the FPGA, in terms of its voltage and frequency, would also
require some advanced research.

% --------------------------------------------------------------------------------
% --------------------------------------------------------------------------------
\section{Project Specification}
% The project specification should state clearly what the project is intended to
% deliver, including all hardware, software, simulation, and analytical work, and
% provide some motivation.

\subsection{Project Organisation}
This project is a part of a larger project investigating the effect of using
high radix number systems with on-line arithmetic operators.
The overarching aim would involve implementing such a system on FPGA and
quantifying its performance improvements.
This aim would be achieved through two vertically split individual projects.
One would design and verify the arithmetic operator modules,
while the other would design a system from the top-level to test and
evaluate these operators.
This project deals with the system-level issues.

As this project progresses in parallel with the designing of the operator
modules, it is necessary to decouple the two project so that as individual
projects, they are individually evaluated.
The success of one project should not be restricted by the status of the other.
To this end, the goal of the system-level design is more focussed on its
functionalities and robustness.
This relationship and its effect on the evaluation will be examined further in
the evaluation chapter of this report.

\subsection{Project Interfacing}
% REVISIT: necessary? if already decided, what is it?
A number representation system should be decided before detailed design starts.

The modules would be compiled hardware in 

\subsection{Deliverables}
At the end of the project, the system should be able to perform the following:
\begin{enumerate}
  \item Takes in the arithmetic modules designed by the sister project as its
        input;
  \item Generate and run tests on these modules;
  \item Vary the frequency and voltage of the FPGA;
  \item Evaluate its performance.
\end{enumerate}

\subsection{Hardware Choice}
The system itself will be built on a Cyclone V SX SoC Development Board from
Intel~\cite{Intel1}.

\begin{figure}[H]
  \centering
  \includegraphics[width=8cm]{img/SoCStructure}
  \caption{Structure of the System-on-Chip}
  \label{SoCStructure}
\end{figure}

The 5CSXFC6D6F31C6N SoC has a Am Cortex-A9 MPCore accompanied by Intel's 28nm
FPGA fabric~\cite{Altera1}.
The FPGA is necessary for implementing the hardware design and obtaining
empirical results for the project.
% REVISIT: is this true? why do we need an HPS?
Having an HPS on the same chip is useful as the test software can run on it,
allowing a better user interface to be constructed with more detailed,
on-the-fly control to the FPGA.

It should be noted that Xilinx offers similar boards as well. Its Zynq SoC
family has a very comparable structure as they too integrate the software
programmability of an Arm processor with the hardware possibility of an FPGA.
For example, like the Cyclone V SX, Zynq-7000S also features a Arm Cortex-A9
coupled with a Xilinx 28nm FPGA~\cite{Xilinx1}.

% REVISIT: need to show evidence for their similarity?
As there are very few significant functional differences between the two brands,
this project will initially explore with the Intel board, simply for its
availability and the personal familiarity with their development tools.

Once the project has progressed to a point where the system design is mature and
tested, the Xilinx alternative could be explored as an extension.

\subsection{Software Choice}
The software choice follows closely with the hardware choice in this project.
To develop for Intel FPGA, Quartus needs to be used.
% REVISIT: are you sure about this one?
The version picked is arbitrary as there is not much functional difference
between the versions that would be critical to the project.
As Quartus Prime 16.0 is the version installed in the computers in the
department.
The project will be using the same version for the convenience.
This naturally means the hardware system will be build with the system
integration tool that comes with Quartus -- Qsys.

Other than the hardware design tools, there are some freedom of choice in the
HPS side of the project.
The test will be build with Python, which will be running on an Ubuntu system
that is installed in the HPS.
This choice is made for there are previous unrelated projects on the same
develop board that uses the same configuration, which means a lot of time
could be saved on getting an operating system booting.



% --------------------------------------------------------------------------------
% --------------------------------------------------------------------------------
\section{Implementation Plan}
% The implementation plan is a preliminary breakdown of the work that is to be
% done in the remainder of the project. You should identify a set of milestones
% and provide a realistic estimate of when each of these should be completed if
% all goes well. It should also detail fallback positions in case any stage of the
% development goes wrong. You may feel, in the early stages of your project work,
% that the times in this plan are guesses. However you will find as the project
% progresses that keeping track of and revising your initial estimates, and if
% necessary altering the proposed work, is a vital way to ensure that the project
% is finished in time. In projects with heavy implementation content you should
% document what you have already completed.
\subsection{Milestones}
The initial deliverable for the engineering side involves running a simple
program on the FPGA through the HPS with the FPGA frequency being controllable.
After this, the next critical step would be making sure the modules under test
will be the point of failure and not the testbench.
This would include some research on ways in improving the speed of feeding
inputs to the arithmetic units, and checking its outputs.
Once this could be confirmed, we can start adding a selection of different functionalities.

\begin{enumerate}
  \item Running standard benchmarks;
  \item Running key algorithms or their components;
  \item Experiment with other power efficiency improving techniques,
        such as undervolting;
  \item Add support for configurable radix arithmetic;
  \item Allow graceful failures for the testbench in case of unintended
        behaviour for the arithmetic modules;
  \item Add an interactive UI to control the voltage and frequency at run time
        and examine the DUT’s behaviour;
\end{enumerate}

Depending on the time situation, more or less items on this list may be fulfilled.
The method of evaluation will be discussed later in the evaluation chapter.
\subsection{Work to Date}



% --------------------------------------------------------------------------------
% --------------------------------------------------------------------------------
\section{Evaluation Plan}
% The evaluation plan should detail how you expect to measure the success of the
% project. In particular it should document any tests that are required to ensure
% that the project deliverable(s) function correctly, together with (where
% appropriate) details of experiments required to evaluate the work with respect
% to other products or research results.

\subsection{Metrics}

\subsection{Risks}
A major risk of this project is related to its schedule and the existence of an
initial blocking task.
While most of the later sections of the project can be selectively added or
removed from the scope relatively easily, the initial setup of the testbench
will always remain critical to any further improvements.
It is thus vital that the bare minimum system gets done early.
To ensure this happens, it will be placed in the highest priority before its
completion, and any blocking issue should be discussed with the supervisor if it
could not be resolved after significant effort.

The other major risk has to do with the progress of the sister project.
The purpose of the testbench is to verify and stress the arithmetic designs.
If these designs would not be available near the end of this project,
it would be difficult to empirically prove the capabilities of the testbench
and its surrounding system.
It is not impossible, as there are still substitutions for them.
For functional purposes, standard off-the-shelf adders and multipliers could be
used in-lieu.
For other purposes, it is possible to have a model done before the actual design
starts in the paired project.
While this would allow this project to progress easier, it would be extra work
for the other project, which is ultimately up to the decision of the other
student.
In all, it would be nice to have a solid arithmetic module completely to run
in this testbench, but without one, the system can still be built and completed,
albeit generating less useful data towards the overall aim of the project.

% --------------------------------------------------------------------------------
% --------------------------------------------------------------------------------
\section{Ethical, Legal, and Safety Plan}
% The Ethical, Legal and Safety Plan must detail what are the issues in this are
% relevant to your project, showing how you will comply with best practice. If
% there are no such issues (the case for 80\% of all projects) you must
% nevertheless show here that you have considered these issues and detail why they
% will not apply to your project. Information will be provided on the project web
% pages about Ethical, Legal and Safety matters.

\subsection{Ethical Considerations}
% Ethics: Research projects are required to get ethical approval if they may have
% issues. It is not at all usual for EEE FYPs to have such issues, but you should
% be aware of the possibility, most usually relating to personal data when you
% conduct questionnaires or do user testing.

Checking against the ethical issue list provided by Imperial College Research
Ethics Committee~\cite{Imperial1}, this project
\begin{itemize}
  \item does not damage participants' mental or physical health;
  \item does not jeopardise the safety and liberty of the researchers;
  \item does not use any private information;
  \item does not involve sensitive subject matter or methods;
  \item does not risk any conflict of interest between the researchers and
        the College.
\end{itemize}
This project is thus free from significant ethical concerns.

\subsection{Legal Considerations}
% Legal issues: the obvious one here is patent protection. Your work may infringe
% patents (which does not affect the project itself, but might affect
% commercialisation). You are not required to do a patent search but should be
% aware of the possibility if you have a deliverable that could be commercialised.
% Also, your work may (if it goes well) be patentable. You can usually check this
% with your supervisor. If so you will need to ensure that nothing you do
% prejudices this possibility. There may also be regulatory issues with
% electromagnetic radiation.
% REVISIT: ask James
Intel Quartus Prime software offers a variety of IP cores.
These are encrypted module designs that would be integrated into the
verification system of the project~\cite{Intel2}.
Intel FPGA Evaluation Mode allows

\subsection{Safety Considerations}
% Safety: check with your supervior (who is ultimately responsible for safety in
% your lab work). Also, you can get information from the lab staff - e.g. Vic
% Boddy - about possible safety issues in the lab. Note that Vic is not
% responsible for safety, though quite knowledgable, so you must also check this
% with your supervisor. Many projects will have no lab work and therefore no
% safety issues.
As the project is done mainly on a computer with minimum physical aspects,
there is no major safety concern.
For the minor concerns associated with the project, 
the physical development board will be handled with care, and the desk works
will be interleaved with breaks.

% --------------------------------------------------------------------------------
% --------------------------------------------------------------------------------
\section{Conclusion}


\newpage
\appendices

\section{Formulae}
$$1 + 1 = 2$$

\section{Data}

\begin{table}[H]
  \centering
  \begin{tabular}{c|cccc}
    Sum             & $1$ & $2$ & $3$ & $4$ \\
    \hline
    $1$             & $2$ & $3$ & $4$ & $5$ \\
    $2$             & $3$ & $4$ & $5$ & $6$ \\
  \end{tabular}
\end{table}

\begin{thebibliography}{1}
% Unused:
% M. D. Ercegovac and T. Lang. Digital Arithmetic

\bibitem{Intel1}
  Intel Corporation,
  ``\textit{Cyclone V SoC Development Kit and Intel SoC FPGA Embedded
  Development Suite}''.
  % Available at:\\\url{www.intel.com/content/www/us/en/programmable/products/
  % boards_and_kits/dev-kits/altera/kit-cyclone-v-soc.html}.

\bibitem{Altera1}
  Altera Corporation,
  ``\textit{Cyclone V SoC Development Board Reference Manual}'',
  2015.
  % Available at:\\\url{www.intel.com/content/dam/www/programmable/us/en/pdfs/
  % literature/manual/rm_cv_soc_dev_board.pdf}.

\bibitem{Xilinx1}
  Xilinx, Inc,
  ``\textit{Zynq-7000 All Programmable SoC}'',
  2018.
  % Available at:\\\url{www.xilinx.com/support/documentation/
  % product-briefs/zynq-7000-product-brief.pdf}.

\bibitem{Brent1}
  R.P. Brent,
  ``\textit{A Regular Layout for Parallel Adders}'',
  \textit{IEEE Trans. Comput.}, vol. C-31, pp. 260-264,
  1982.

\bibitem{Srinivas1}
  H.R. Srinivas, K.K. Parhi,
  ``\textit{High-Speed VLSI Arithmetic Processor Architectures Using Hybrid
  Number Representation}'',
  \textit{J. of VLSI Sign. Process.}, vol. 4. pp. 177-198,
  1992.

\bibitem{Zhao1}
  Y. Zhao, J. Wickerson, G.A. Constantinides,
  ``\textit{An Efficient Implementation of Online Arithmetic}'',
  \textit{Int. Conf. on Field-Programmable Technology},
  2016.

\bibitem{Duncan1}
  R. Duncan,
  ``\textit{A Survey of Parallel Computer Architectures}'',
  \textit{Computer}, vol. 23, pp. 5-16,
  1990.

\bibitem{Ercegovac1}
  M.D. Ercegovac,
  ``\textit{On-line Arithmetic: An Overview}'',
  \textit{28th Annual Technical Symposium}, pp. 86-93,
  Internaltional Society for Optics and Photonics,
  1984.

\bibitem{Trivedi1}
  K.S. Trivedi, M.D. Ercegovac,
  ``\textit{On-line Algorithms for Division and Multiplication}'',
  \textit{IEEE Trans. Comput.}, vol. C-26, no. 7, pp. 667-680,
  1977.

\bibitem{Shi1}
  K. Shi, D. Boland, G.A. Constantinides,
  ``\textit{Accuracy-Performance Tradeoffs on an FPGA through Overclocking}'',
  \textit{Proc. Int. Symp. Field-Programmable Custom Computing Machines},
  pp. 29-36,
  2013.

\bibitem{Shi2}
  K. Shi, D. Boland, E. Stott, S. Bayliss, G.A. Constantinides,
  ``\textit{Datapath Synthesis for Overclocking: Online Arithmetic for
  Latency-Accuracy Trade-offs}'',
  \textit{Proceedings of the 13th Symposium on Field-Programmable Custom
  Computing Machines},
  pp. 1-6, ACM,
  2014.

\bibitem{Whyte1}
  P. Whyte,
  ``\textit{Design and Implementation of High-radix Arithmetic Systems Based
  on the SDNR/RNS Data Representation}''
  \textit{Edith Cowan University},
  1997.

\bibitem{Catanzaro1}
  B. Catanzaro, B. Nelson,
  ``\textit{Higher Radix Floating-Point Representations for FPGA-Based
  Arithmetic}'',
  \textit{Proceedings of the 51st Annual Design Automation Conference},
  2005.

\bibitem{Lynch1}
  T. Lynch, M.J. Schulte,
  ``\textit{A High Radix On-line Arithmetic for Credible and Accurate
  Computing}'',
  \textit{Journal of Universal Computer Science}, vol. 1, no. 7, pp. 439-453,
  1995.

\bibitem{Lynch2}
  T. Lynch, M.J. Schulte,
  ``\textit{Software for High Radix On-line Arithmetic}'',
  \textit{Reliable Computing}, vol. 2, no. 2, pp. 133-138,
  1996.

\bibitem{Imperial1}
  Imperial College
  ``\textit{An Ethics Code}'',
  \textit{Imperial College Research Ethics Committee},
  2013.

\bibitem{Intel2}
  Intel Corporation,
  ``\textit{Introduction to Intel® FPGA IP Cores}'',
  2018.

\end{thebibliography}

\end{document}